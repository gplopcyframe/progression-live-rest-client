<?php
/**
 * TasksApi
 * PHP version 5
 *
 * @category Class
 * @package  ProgressionLive
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * ProgressionLIVE API
 *
 * Welcome to the ProgressionLIVE REST API documentation page.    The data exchange format is [JSON](https://en.wikipedia.org/wiki/JavaScript_Object_Notation). This format facilitates the exchange of data with almost all systems while minimizing the amount of data.    All API operations are listed on this page and can be tested directly.    An [OpenAPI](https://github.com/OAI/OpenAPI-Specification) specification file is available at the link above and allows you to generate clients in several languages ​​using [Swagger](https://swagger.io/swagger-codegen/) tools.    The examples on this page use the command-line tool from the well-known Unix family of systems [CURL](https://curl.haxx.se/). This demonstrates the ease of integration. Note that it is possible to install CURL under Microsoft Windows but it's not necessary for the development of an integration. .NET technologies also make it easy to connect to a [REST / JSON API](https://docs.microsoft.com/en-us/aspnet/web-api/overview/advanced/calling-a-web-api-from-a-net-client).    At the authentication level, 3 options are available:    #### HTTP Basic  This mechanism uses standard HTTP authentication supported by the majority of HTTP clients. Just provide your API key as a user without a password. If you have to do it programmatically, you must add an \"Authorization: Basic&lt;base64 encoded apikey:&gt;\" header.    #### HTTP Bearer  This mechanism uses the same header as HTTP Basic authentication but makes adding a header manually easier. Just add an \"Authorization: Bearer&lt;apikey&gt;\" header.    #### Query  In the case where it would be too complex or impossible for you to add authentication headers on the programming platform used, it is possible to add an apiKey = &lt;apikey&gt; parameter to the URL of each request. e.g.: https://macie.progressionlive.com/server/rest/task/1234?apikey=&lt;apikey&gt;
 *
 * OpenAPI spec version: 1.0
 * Contact: support@progressionlive.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.35
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace ProgressionLive\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use ProgressionLive\ApiException;
use ProgressionLive\Configuration;
use ProgressionLive\HeaderSelector;
use ProgressionLive\ObjectSerializer;

/**
 * TasksApi Class Doc Comment
 *
 * @category Class
 * @package  ProgressionLive
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class TasksApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation taskAssignPost
     *
     * Assign many tasks.
     *
     * @param  \ProgressionLive\Model\MultipleProgressRequest $body MultipleProgressRequest (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProgressionLive\Model\ProgressResult[]
     */
    public function taskAssignPost($body)
    {
        list($response) = $this->taskAssignPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation taskAssignPostWithHttpInfo
     *
     * Assign many tasks.
     *
     * @param  \ProgressionLive\Model\MultipleProgressRequest $body MultipleProgressRequest (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProgressionLive\Model\ProgressResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function taskAssignPostWithHttpInfo($body)
    {
        $returnType = '\ProgressionLive\Model\ProgressResult[]';
        $request = $this->taskAssignPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\ProgressResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\InlineResponse500',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskAssignPostAsync
     *
     * Assign many tasks.
     *
     * @param  \ProgressionLive\Model\MultipleProgressRequest $body MultipleProgressRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskAssignPostAsync($body)
    {
        return $this->taskAssignPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskAssignPostAsyncWithHttpInfo
     *
     * Assign many tasks.
     *
     * @param  \ProgressionLive\Model\MultipleProgressRequest $body MultipleProgressRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskAssignPostAsyncWithHttpInfo($body)
    {
        $returnType = '\ProgressionLive\Model\ProgressResult[]';
        $request = $this->taskAssignPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskAssignPost'
     *
     * @param  \ProgressionLive\Model\MultipleProgressRequest $body MultipleProgressRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskAssignPostRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling taskAssignPost'
            );
        }

        $resourcePath = '/task/assign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskAttachmentIdentifierGet
     *
     * @param  string $identifier Attachment&#x27;s identifier. Id or uid. See &#x27;Task.attachments&#x27;. (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProgressionLive\Model\Attachment
     */
    public function taskAttachmentIdentifierGet($identifier)
    {
        list($response) = $this->taskAttachmentIdentifierGetWithHttpInfo($identifier);
        return $response;
    }

    /**
     * Operation taskAttachmentIdentifierGetWithHttpInfo
     *
     * @param  string $identifier Attachment&#x27;s identifier. Id or uid. See &#x27;Task.attachments&#x27;. (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProgressionLive\Model\Attachment, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskAttachmentIdentifierGetWithHttpInfo($identifier)
    {
        $returnType = '\ProgressionLive\Model\Attachment';
        $request = $this->taskAttachmentIdentifierGetRequest($identifier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\Attachment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\InlineResponse500',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskAttachmentIdentifierGetAsync
     *
     * 
     *
     * @param  string $identifier Attachment&#x27;s identifier. Id or uid. See &#x27;Task.attachments&#x27;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskAttachmentIdentifierGetAsync($identifier)
    {
        return $this->taskAttachmentIdentifierGetAsyncWithHttpInfo($identifier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskAttachmentIdentifierGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $identifier Attachment&#x27;s identifier. Id or uid. See &#x27;Task.attachments&#x27;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskAttachmentIdentifierGetAsyncWithHttpInfo($identifier)
    {
        $returnType = '\ProgressionLive\Model\Attachment';
        $request = $this->taskAttachmentIdentifierGetRequest($identifier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskAttachmentIdentifierGet'
     *
     * @param  string $identifier Attachment&#x27;s identifier. Id or uid. See &#x27;Task.attachments&#x27;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskAttachmentIdentifierGetRequest($identifier)
    {
        // verify the required parameter 'identifier' is set
        if ($identifier === null || (is_array($identifier) && count($identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identifier when calling taskAttachmentIdentifierGet'
            );
        }

        $resourcePath = '/task/attachment/{identifier}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'identifier' . '}',
                ObjectSerializer::toPathValue($identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskAttachmentIdentifierPost
     *
     * @param  \ProgressionLive\Model\Attachment $body Attachment to update. (required)
     * @param  string $identifier Attachment&#x27;s identifier. id or uid. (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function taskAttachmentIdentifierPost($body, $identifier)
    {
        $this->taskAttachmentIdentifierPostWithHttpInfo($body, $identifier);
    }

    /**
     * Operation taskAttachmentIdentifierPostWithHttpInfo
     *
     * @param  \ProgressionLive\Model\Attachment $body Attachment to update. (required)
     * @param  string $identifier Attachment&#x27;s identifier. id or uid. (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskAttachmentIdentifierPostWithHttpInfo($body, $identifier)
    {
        $returnType = '';
        $request = $this->taskAttachmentIdentifierPostRequest($body, $identifier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\InlineResponse500',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskAttachmentIdentifierPostAsync
     *
     * 
     *
     * @param  \ProgressionLive\Model\Attachment $body Attachment to update. (required)
     * @param  string $identifier Attachment&#x27;s identifier. id or uid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskAttachmentIdentifierPostAsync($body, $identifier)
    {
        return $this->taskAttachmentIdentifierPostAsyncWithHttpInfo($body, $identifier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskAttachmentIdentifierPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \ProgressionLive\Model\Attachment $body Attachment to update. (required)
     * @param  string $identifier Attachment&#x27;s identifier. id or uid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskAttachmentIdentifierPostAsyncWithHttpInfo($body, $identifier)
    {
        $returnType = '';
        $request = $this->taskAttachmentIdentifierPostRequest($body, $identifier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskAttachmentIdentifierPost'
     *
     * @param  \ProgressionLive\Model\Attachment $body Attachment to update. (required)
     * @param  string $identifier Attachment&#x27;s identifier. id or uid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskAttachmentIdentifierPostRequest($body, $identifier)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling taskAttachmentIdentifierPost'
            );
        }
        // verify the required parameter 'identifier' is set
        if ($identifier === null || (is_array($identifier) && count($identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identifier when calling taskAttachmentIdentifierPost'
            );
        }

        $resourcePath = '/task/attachment/{identifier}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'identifier' . '}',
                ObjectSerializer::toPathValue($identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskCreatePost
     *
     * Create a task.
     *
     * @param  \ProgressionLive\Model\Task $body Task (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProgressionLive\Model\EntityRef
     */
    public function taskCreatePost($body)
    {
        list($response) = $this->taskCreatePostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation taskCreatePostWithHttpInfo
     *
     * Create a task.
     *
     * @param  \ProgressionLive\Model\Task $body Task (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProgressionLive\Model\EntityRef, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskCreatePostWithHttpInfo($body)
    {
        $returnType = '\ProgressionLive\Model\EntityRef';
        $request = $this->taskCreatePostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\EntityRef',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\InlineResponse500',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskCreatePostAsync
     *
     * Create a task.
     *
     * @param  \ProgressionLive\Model\Task $body Task (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskCreatePostAsync($body)
    {
        return $this->taskCreatePostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskCreatePostAsyncWithHttpInfo
     *
     * Create a task.
     *
     * @param  \ProgressionLive\Model\Task $body Task (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskCreatePostAsyncWithHttpInfo($body)
    {
        $returnType = '\ProgressionLive\Model\EntityRef';
        $request = $this->taskCreatePostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskCreatePost'
     *
     * @param  \ProgressionLive\Model\Task $body Task (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskCreatePostRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling taskCreatePost'
            );
        }

        $resourcePath = '/task/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskDispatchPost
     *
     * Dispatch many tasks. Sends the task to the mobile device of the resource. If no resource is specified, the currently assigned resource will be used.
     *
     * @param  \ProgressionLive\Model\MultipleProgressRequest $body MultipleProgressRequest (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProgressionLive\Model\ProgressResult[]
     */
    public function taskDispatchPost($body)
    {
        list($response) = $this->taskDispatchPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation taskDispatchPostWithHttpInfo
     *
     * Dispatch many tasks. Sends the task to the mobile device of the resource. If no resource is specified, the currently assigned resource will be used.
     *
     * @param  \ProgressionLive\Model\MultipleProgressRequest $body MultipleProgressRequest (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProgressionLive\Model\ProgressResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function taskDispatchPostWithHttpInfo($body)
    {
        $returnType = '\ProgressionLive\Model\ProgressResult[]';
        $request = $this->taskDispatchPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\ProgressResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\InlineResponse500',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskDispatchPostAsync
     *
     * Dispatch many tasks. Sends the task to the mobile device of the resource. If no resource is specified, the currently assigned resource will be used.
     *
     * @param  \ProgressionLive\Model\MultipleProgressRequest $body MultipleProgressRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskDispatchPostAsync($body)
    {
        return $this->taskDispatchPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskDispatchPostAsyncWithHttpInfo
     *
     * Dispatch many tasks. Sends the task to the mobile device of the resource. If no resource is specified, the currently assigned resource will be used.
     *
     * @param  \ProgressionLive\Model\MultipleProgressRequest $body MultipleProgressRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskDispatchPostAsyncWithHttpInfo($body)
    {
        $returnType = '\ProgressionLive\Model\ProgressResult[]';
        $request = $this->taskDispatchPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskDispatchPost'
     *
     * @param  \ProgressionLive\Model\MultipleProgressRequest $body MultipleProgressRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskDispatchPostRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling taskDispatchPost'
            );
        }

        $resourcePath = '/task/dispatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskIdentifierAssignPost
     *
     * Assign a task.
     *
     * @param  \ProgressionLive\Model\EntityRef $body body (required)
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProgressionLive\Model\ProgressResult
     */
    public function taskIdentifierAssignPost($body, $identifier)
    {
        list($response) = $this->taskIdentifierAssignPostWithHttpInfo($body, $identifier);
        return $response;
    }

    /**
     * Operation taskIdentifierAssignPostWithHttpInfo
     *
     * Assign a task.
     *
     * @param  \ProgressionLive\Model\EntityRef $body (required)
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProgressionLive\Model\ProgressResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskIdentifierAssignPostWithHttpInfo($body, $identifier)
    {
        $returnType = '\ProgressionLive\Model\ProgressResult';
        $request = $this->taskIdentifierAssignPostRequest($body, $identifier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\ProgressResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\InlineResponse500',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskIdentifierAssignPostAsync
     *
     * Assign a task.
     *
     * @param  \ProgressionLive\Model\EntityRef $body (required)
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierAssignPostAsync($body, $identifier)
    {
        return $this->taskIdentifierAssignPostAsyncWithHttpInfo($body, $identifier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskIdentifierAssignPostAsyncWithHttpInfo
     *
     * Assign a task.
     *
     * @param  \ProgressionLive\Model\EntityRef $body (required)
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierAssignPostAsyncWithHttpInfo($body, $identifier)
    {
        $returnType = '\ProgressionLive\Model\ProgressResult';
        $request = $this->taskIdentifierAssignPostRequest($body, $identifier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskIdentifierAssignPost'
     *
     * @param  \ProgressionLive\Model\EntityRef $body (required)
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskIdentifierAssignPostRequest($body, $identifier)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling taskIdentifierAssignPost'
            );
        }
        // verify the required parameter 'identifier' is set
        if ($identifier === null || (is_array($identifier) && count($identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identifier when calling taskIdentifierAssignPost'
            );
        }

        $resourcePath = '/task/{identifier}/assign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'identifier' . '}',
                ObjectSerializer::toPathValue($identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskIdentifierAttachmentPost
     *
     * @param  \ProgressionLive\Model\Attachment $body Attachment to add. (required)
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProgressionLive\Model\EntityRef
     */
    public function taskIdentifierAttachmentPost($body, $identifier)
    {
        list($response) = $this->taskIdentifierAttachmentPostWithHttpInfo($body, $identifier);
        return $response;
    }

    /**
     * Operation taskIdentifierAttachmentPostWithHttpInfo
     *
     * @param  \ProgressionLive\Model\Attachment $body Attachment to add. (required)
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProgressionLive\Model\EntityRef, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskIdentifierAttachmentPostWithHttpInfo($body, $identifier)
    {
        $returnType = '\ProgressionLive\Model\EntityRef';
        $request = $this->taskIdentifierAttachmentPostRequest($body, $identifier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\EntityRef',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\InlineResponse500',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskIdentifierAttachmentPostAsync
     *
     * 
     *
     * @param  \ProgressionLive\Model\Attachment $body Attachment to add. (required)
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierAttachmentPostAsync($body, $identifier)
    {
        return $this->taskIdentifierAttachmentPostAsyncWithHttpInfo($body, $identifier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskIdentifierAttachmentPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  \ProgressionLive\Model\Attachment $body Attachment to add. (required)
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierAttachmentPostAsyncWithHttpInfo($body, $identifier)
    {
        $returnType = '\ProgressionLive\Model\EntityRef';
        $request = $this->taskIdentifierAttachmentPostRequest($body, $identifier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskIdentifierAttachmentPost'
     *
     * @param  \ProgressionLive\Model\Attachment $body Attachment to add. (required)
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskIdentifierAttachmentPostRequest($body, $identifier)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling taskIdentifierAttachmentPost'
            );
        }
        // verify the required parameter 'identifier' is set
        if ($identifier === null || (is_array($identifier) && count($identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identifier when calling taskIdentifierAttachmentPost'
            );
        }

        $resourcePath = '/task/{identifier}/attachment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'identifier' . '}',
                ObjectSerializer::toPathValue($identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskIdentifierAttachmentsGet
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function taskIdentifierAttachmentsGet($identifier)
    {
        list($response) = $this->taskIdentifierAttachmentsGetWithHttpInfo($identifier);
        return $response;
    }

    /**
     * Operation taskIdentifierAttachmentsGetWithHttpInfo
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskIdentifierAttachmentsGetWithHttpInfo($identifier)
    {
        $returnType = 'string';
        $request = $this->taskIdentifierAttachmentsGetRequest($identifier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\InlineResponse500',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskIdentifierAttachmentsGetAsync
     *
     * 
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierAttachmentsGetAsync($identifier)
    {
        return $this->taskIdentifierAttachmentsGetAsyncWithHttpInfo($identifier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskIdentifierAttachmentsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierAttachmentsGetAsyncWithHttpInfo($identifier)
    {
        $returnType = 'string';
        $request = $this->taskIdentifierAttachmentsGetRequest($identifier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskIdentifierAttachmentsGet'
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskIdentifierAttachmentsGetRequest($identifier)
    {
        // verify the required parameter 'identifier' is set
        if ($identifier === null || (is_array($identifier) && count($identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identifier when calling taskIdentifierAttachmentsGet'
            );
        }

        $resourcePath = '/task/{identifier}/attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'identifier' . '}',
                ObjectSerializer::toPathValue($identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/zip', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/zip', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskIdentifierDispatchPost
     *
     * Dispatch a task. Sends the task to the mobile device of the resource.  If no resource is specified, the currently assigned resource will be used.
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     * @param  \ProgressionLive\Model\EntityRef $body body (optional)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProgressionLive\Model\ProgressResult
     */
    public function taskIdentifierDispatchPost($identifier, $body = null)
    {
        list($response) = $this->taskIdentifierDispatchPostWithHttpInfo($identifier, $body);
        return $response;
    }

    /**
     * Operation taskIdentifierDispatchPostWithHttpInfo
     *
     * Dispatch a task. Sends the task to the mobile device of the resource.  If no resource is specified, the currently assigned resource will be used.
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     * @param  \ProgressionLive\Model\EntityRef $body (optional)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProgressionLive\Model\ProgressResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskIdentifierDispatchPostWithHttpInfo($identifier, $body = null)
    {
        $returnType = '\ProgressionLive\Model\ProgressResult';
        $request = $this->taskIdentifierDispatchPostRequest($identifier, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\ProgressResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\InlineResponse500',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskIdentifierDispatchPostAsync
     *
     * Dispatch a task. Sends the task to the mobile device of the resource.  If no resource is specified, the currently assigned resource will be used.
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     * @param  \ProgressionLive\Model\EntityRef $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierDispatchPostAsync($identifier, $body = null)
    {
        return $this->taskIdentifierDispatchPostAsyncWithHttpInfo($identifier, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskIdentifierDispatchPostAsyncWithHttpInfo
     *
     * Dispatch a task. Sends the task to the mobile device of the resource.  If no resource is specified, the currently assigned resource will be used.
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     * @param  \ProgressionLive\Model\EntityRef $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierDispatchPostAsyncWithHttpInfo($identifier, $body = null)
    {
        $returnType = '\ProgressionLive\Model\ProgressResult';
        $request = $this->taskIdentifierDispatchPostRequest($identifier, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskIdentifierDispatchPost'
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     * @param  \ProgressionLive\Model\EntityRef $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskIdentifierDispatchPostRequest($identifier, $body = null)
    {
        // verify the required parameter 'identifier' is set
        if ($identifier === null || (is_array($identifier) && count($identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identifier when calling taskIdentifierDispatchPost'
            );
        }

        $resourcePath = '/task/{identifier}/dispatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'identifier' . '}',
                ObjectSerializer::toPathValue($identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskIdentifierEventPost
     *
     * @param  string $identifier The Id of the task (required)
     * @param  string $type The type of the event (DEBUG, INFO, WARN or ERROR) (optional)
     * @param  string $msg The message to add in the event (optional)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function taskIdentifierEventPost($identifier, $type = null, $msg = null)
    {
        $this->taskIdentifierEventPostWithHttpInfo($identifier, $type, $msg);
    }

    /**
     * Operation taskIdentifierEventPostWithHttpInfo
     *
     * @param  string $identifier The Id of the task (required)
     * @param  string $type The type of the event (DEBUG, INFO, WARN or ERROR) (optional)
     * @param  string $msg The message to add in the event (optional)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskIdentifierEventPostWithHttpInfo($identifier, $type = null, $msg = null)
    {
        $returnType = '';
        $request = $this->taskIdentifierEventPostRequest($identifier, $type, $msg);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\InlineResponse500',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskIdentifierEventPostAsync
     *
     * 
     *
     * @param  string $identifier The Id of the task (required)
     * @param  string $type The type of the event (DEBUG, INFO, WARN or ERROR) (optional)
     * @param  string $msg The message to add in the event (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierEventPostAsync($identifier, $type = null, $msg = null)
    {
        return $this->taskIdentifierEventPostAsyncWithHttpInfo($identifier, $type, $msg)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskIdentifierEventPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $identifier The Id of the task (required)
     * @param  string $type The type of the event (DEBUG, INFO, WARN or ERROR) (optional)
     * @param  string $msg The message to add in the event (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierEventPostAsyncWithHttpInfo($identifier, $type = null, $msg = null)
    {
        $returnType = '';
        $request = $this->taskIdentifierEventPostRequest($identifier, $type, $msg);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskIdentifierEventPost'
     *
     * @param  string $identifier The Id of the task (required)
     * @param  string $type The type of the event (DEBUG, INFO, WARN or ERROR) (optional)
     * @param  string $msg The message to add in the event (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskIdentifierEventPostRequest($identifier, $type = null, $msg = null)
    {
        // verify the required parameter 'identifier' is set
        if ($identifier === null || (is_array($identifier) && count($identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identifier when calling taskIdentifierEventPost'
            );
        }

        $resourcePath = '/task/{identifier}/event';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type, null);
        }
        // query params
        if ($msg !== null) {
            $queryParams['msg'] = ObjectSerializer::toQueryValue($msg, null);
        }

        // path params
        if ($identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'identifier' . '}',
                ObjectSerializer::toPathValue($identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskIdentifierGet
     *
     * Get a task.
     *
     * @param  string $identifier Task&#x27;s identifier. One of id, uid, externalId or code. (required)
     * @param  string $expand expand (optional)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProgressionLive\Model\Task
     */
    public function taskIdentifierGet($identifier, $expand = null)
    {
        list($response) = $this->taskIdentifierGetWithHttpInfo($identifier, $expand);
        return $response;
    }

    /**
     * Operation taskIdentifierGetWithHttpInfo
     *
     * Get a task.
     *
     * @param  string $identifier Task&#x27;s identifier. One of id, uid, externalId or code. (required)
     * @param  string $expand (optional)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProgressionLive\Model\Task, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskIdentifierGetWithHttpInfo($identifier, $expand = null)
    {
        $returnType = '\ProgressionLive\Model\Task';
        $request = $this->taskIdentifierGetRequest($identifier, $expand);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\Task',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\InlineResponse500',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskIdentifierGetAsync
     *
     * Get a task.
     *
     * @param  string $identifier Task&#x27;s identifier. One of id, uid, externalId or code. (required)
     * @param  string $expand (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierGetAsync($identifier, $expand = null)
    {
        return $this->taskIdentifierGetAsyncWithHttpInfo($identifier, $expand)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskIdentifierGetAsyncWithHttpInfo
     *
     * Get a task.
     *
     * @param  string $identifier Task&#x27;s identifier. One of id, uid, externalId or code. (required)
     * @param  string $expand (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierGetAsyncWithHttpInfo($identifier, $expand = null)
    {
        $returnType = '\ProgressionLive\Model\Task';
        $request = $this->taskIdentifierGetRequest($identifier, $expand);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskIdentifierGet'
     *
     * @param  string $identifier Task&#x27;s identifier. One of id, uid, externalId or code. (required)
     * @param  string $expand (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskIdentifierGetRequest($identifier, $expand = null)
    {
        // verify the required parameter 'identifier' is set
        if ($identifier === null || (is_array($identifier) && count($identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identifier when calling taskIdentifierGet'
            );
        }

        $resourcePath = '/task/{identifier}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($expand !== null) {
            $queryParams['expand'] = ObjectSerializer::toQueryValue($expand, null);
        }

        // path params
        if ($identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'identifier' . '}',
                ObjectSerializer::toPathValue($identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskIdentifierLinkPost
     *
     * Link a task to a parent task. If no parent task found, an error is returned.
     *
     * @param  \ProgressionLive\Model\EntityRef $body body (required)
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProgressionLive\Model\ProgressResult
     */
    public function taskIdentifierLinkPost($body, $identifier)
    {
        list($response) = $this->taskIdentifierLinkPostWithHttpInfo($body, $identifier);
        return $response;
    }

    /**
     * Operation taskIdentifierLinkPostWithHttpInfo
     *
     * Link a task to a parent task. If no parent task found, an error is returned.
     *
     * @param  \ProgressionLive\Model\EntityRef $body (required)
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProgressionLive\Model\ProgressResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskIdentifierLinkPostWithHttpInfo($body, $identifier)
    {
        $returnType = '\ProgressionLive\Model\ProgressResult';
        $request = $this->taskIdentifierLinkPostRequest($body, $identifier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\ProgressResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\InlineResponse500',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskIdentifierLinkPostAsync
     *
     * Link a task to a parent task. If no parent task found, an error is returned.
     *
     * @param  \ProgressionLive\Model\EntityRef $body (required)
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierLinkPostAsync($body, $identifier)
    {
        return $this->taskIdentifierLinkPostAsyncWithHttpInfo($body, $identifier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskIdentifierLinkPostAsyncWithHttpInfo
     *
     * Link a task to a parent task. If no parent task found, an error is returned.
     *
     * @param  \ProgressionLive\Model\EntityRef $body (required)
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierLinkPostAsyncWithHttpInfo($body, $identifier)
    {
        $returnType = '\ProgressionLive\Model\ProgressResult';
        $request = $this->taskIdentifierLinkPostRequest($body, $identifier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskIdentifierLinkPost'
     *
     * @param  \ProgressionLive\Model\EntityRef $body (required)
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskIdentifierLinkPostRequest($body, $identifier)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling taskIdentifierLinkPost'
            );
        }
        // verify the required parameter 'identifier' is set
        if ($identifier === null || (is_array($identifier) && count($identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identifier when calling taskIdentifierLinkPost'
            );
        }

        $resourcePath = '/task/{identifier}/link';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'identifier' . '}',
                ObjectSerializer::toPathValue($identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskIdentifierLinksGet
     *
     * Get a task's subtasks.
     *
     * @param  string $identifier Task&#x27;s identifier. One of id, uid, externalId or code. (required)
     * @param  string $expand expand (optional)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProgressionLive\Model\Task[]
     */
    public function taskIdentifierLinksGet($identifier, $expand = null)
    {
        list($response) = $this->taskIdentifierLinksGetWithHttpInfo($identifier, $expand);
        return $response;
    }

    /**
     * Operation taskIdentifierLinksGetWithHttpInfo
     *
     * Get a task's subtasks.
     *
     * @param  string $identifier Task&#x27;s identifier. One of id, uid, externalId or code. (required)
     * @param  string $expand (optional)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProgressionLive\Model\Task[], HTTP status code, HTTP response headers (array of strings)
     */
    public function taskIdentifierLinksGetWithHttpInfo($identifier, $expand = null)
    {
        $returnType = '\ProgressionLive\Model\Task[]';
        $request = $this->taskIdentifierLinksGetRequest($identifier, $expand);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\Task[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\InlineResponse500',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskIdentifierLinksGetAsync
     *
     * Get a task's subtasks.
     *
     * @param  string $identifier Task&#x27;s identifier. One of id, uid, externalId or code. (required)
     * @param  string $expand (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierLinksGetAsync($identifier, $expand = null)
    {
        return $this->taskIdentifierLinksGetAsyncWithHttpInfo($identifier, $expand)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskIdentifierLinksGetAsyncWithHttpInfo
     *
     * Get a task's subtasks.
     *
     * @param  string $identifier Task&#x27;s identifier. One of id, uid, externalId or code. (required)
     * @param  string $expand (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierLinksGetAsyncWithHttpInfo($identifier, $expand = null)
    {
        $returnType = '\ProgressionLive\Model\Task[]';
        $request = $this->taskIdentifierLinksGetRequest($identifier, $expand);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskIdentifierLinksGet'
     *
     * @param  string $identifier Task&#x27;s identifier. One of id, uid, externalId or code. (required)
     * @param  string $expand (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskIdentifierLinksGetRequest($identifier, $expand = null)
    {
        // verify the required parameter 'identifier' is set
        if ($identifier === null || (is_array($identifier) && count($identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identifier when calling taskIdentifierLinksGet'
            );
        }

        $resourcePath = '/task/{identifier}/links';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($expand !== null) {
            $queryParams['expand'] = ObjectSerializer::toQueryValue($expand, null);
        }

        // path params
        if ($identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'identifier' . '}',
                ObjectSerializer::toPathValue($identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskIdentifierSignatureGet
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProgressionLive\Model\FileData
     */
    public function taskIdentifierSignatureGet($identifier)
    {
        list($response) = $this->taskIdentifierSignatureGetWithHttpInfo($identifier);
        return $response;
    }

    /**
     * Operation taskIdentifierSignatureGetWithHttpInfo
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProgressionLive\Model\FileData, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskIdentifierSignatureGetWithHttpInfo($identifier)
    {
        $returnType = '\ProgressionLive\Model\FileData';
        $request = $this->taskIdentifierSignatureGetRequest($identifier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\FileData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\InlineResponse500',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskIdentifierSignatureGetAsync
     *
     * 
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierSignatureGetAsync($identifier)
    {
        return $this->taskIdentifierSignatureGetAsyncWithHttpInfo($identifier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskIdentifierSignatureGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierSignatureGetAsyncWithHttpInfo($identifier)
    {
        $returnType = '\ProgressionLive\Model\FileData';
        $request = $this->taskIdentifierSignatureGetRequest($identifier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskIdentifierSignatureGet'
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskIdentifierSignatureGetRequest($identifier)
    {
        // verify the required parameter 'identifier' is set
        if ($identifier === null || (is_array($identifier) && count($identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identifier when calling taskIdentifierSignatureGet'
            );
        }

        $resourcePath = '/task/{identifier}/signature';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'identifier' . '}',
                ObjectSerializer::toPathValue($identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskIdentifierSignatureHrGet
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProgressionLive\Model\FileData
     */
    public function taskIdentifierSignatureHrGet($identifier)
    {
        list($response) = $this->taskIdentifierSignatureHrGetWithHttpInfo($identifier);
        return $response;
    }

    /**
     * Operation taskIdentifierSignatureHrGetWithHttpInfo
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProgressionLive\Model\FileData, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskIdentifierSignatureHrGetWithHttpInfo($identifier)
    {
        $returnType = '\ProgressionLive\Model\FileData';
        $request = $this->taskIdentifierSignatureHrGetRequest($identifier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\FileData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\InlineResponse500',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskIdentifierSignatureHrGetAsync
     *
     * 
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierSignatureHrGetAsync($identifier)
    {
        return $this->taskIdentifierSignatureHrGetAsyncWithHttpInfo($identifier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskIdentifierSignatureHrGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierSignatureHrGetAsyncWithHttpInfo($identifier)
    {
        $returnType = '\ProgressionLive\Model\FileData';
        $request = $this->taskIdentifierSignatureHrGetRequest($identifier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskIdentifierSignatureHrGet'
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskIdentifierSignatureHrGetRequest($identifier)
    {
        // verify the required parameter 'identifier' is set
        if ($identifier === null || (is_array($identifier) && count($identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identifier when calling taskIdentifierSignatureHrGet'
            );
        }

        $resourcePath = '/task/{identifier}/signature/hr';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'identifier' . '}',
                ObjectSerializer::toPathValue($identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskIdentifierSignatureOtherGet
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProgressionLive\Model\FileData
     */
    public function taskIdentifierSignatureOtherGet($identifier)
    {
        list($response) = $this->taskIdentifierSignatureOtherGetWithHttpInfo($identifier);
        return $response;
    }

    /**
     * Operation taskIdentifierSignatureOtherGetWithHttpInfo
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProgressionLive\Model\FileData, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskIdentifierSignatureOtherGetWithHttpInfo($identifier)
    {
        $returnType = '\ProgressionLive\Model\FileData';
        $request = $this->taskIdentifierSignatureOtherGetRequest($identifier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\FileData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\InlineResponse500',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskIdentifierSignatureOtherGetAsync
     *
     * 
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierSignatureOtherGetAsync($identifier)
    {
        return $this->taskIdentifierSignatureOtherGetAsyncWithHttpInfo($identifier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskIdentifierSignatureOtherGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierSignatureOtherGetAsyncWithHttpInfo($identifier)
    {
        $returnType = '\ProgressionLive\Model\FileData';
        $request = $this->taskIdentifierSignatureOtherGetRequest($identifier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskIdentifierSignatureOtherGet'
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskIdentifierSignatureOtherGetRequest($identifier)
    {
        // verify the required parameter 'identifier' is set
        if ($identifier === null || (is_array($identifier) && count($identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identifier when calling taskIdentifierSignatureOtherGet'
            );
        }

        $resourcePath = '/task/{identifier}/signature/other';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'identifier' . '}',
                ObjectSerializer::toPathValue($identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskIdentifierStateGet
     *
     * Get a task's state history.
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     * @param  string $expand expand (optional)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProgressionLive\Model\TaskState[]
     */
    public function taskIdentifierStateGet($identifier, $expand = null)
    {
        list($response) = $this->taskIdentifierStateGetWithHttpInfo($identifier, $expand);
        return $response;
    }

    /**
     * Operation taskIdentifierStateGetWithHttpInfo
     *
     * Get a task's state history.
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     * @param  string $expand (optional)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProgressionLive\Model\TaskState[], HTTP status code, HTTP response headers (array of strings)
     */
    public function taskIdentifierStateGetWithHttpInfo($identifier, $expand = null)
    {
        $returnType = '\ProgressionLive\Model\TaskState[]';
        $request = $this->taskIdentifierStateGetRequest($identifier, $expand);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\TaskState[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\InlineResponse500',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskIdentifierStateGetAsync
     *
     * Get a task's state history.
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     * @param  string $expand (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierStateGetAsync($identifier, $expand = null)
    {
        return $this->taskIdentifierStateGetAsyncWithHttpInfo($identifier, $expand)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskIdentifierStateGetAsyncWithHttpInfo
     *
     * Get a task's state history.
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     * @param  string $expand (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierStateGetAsyncWithHttpInfo($identifier, $expand = null)
    {
        $returnType = '\ProgressionLive\Model\TaskState[]';
        $request = $this->taskIdentifierStateGetRequest($identifier, $expand);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskIdentifierStateGet'
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     * @param  string $expand (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskIdentifierStateGetRequest($identifier, $expand = null)
    {
        // verify the required parameter 'identifier' is set
        if ($identifier === null || (is_array($identifier) && count($identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identifier when calling taskIdentifierStateGet'
            );
        }

        $resourcePath = '/task/{identifier}/state';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($expand !== null) {
            $queryParams['expand'] = ObjectSerializer::toQueryValue($expand, null);
        }

        // path params
        if ($identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'identifier' . '}',
                ObjectSerializer::toPathValue($identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskIdentifierStatePost
     *
     * Change task's state.
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     * @param  \ProgressionLive\Model\Position $body To add a manual position (GPS point), the task must absolutely have an assigned human resource or else this command will be ignored (optional)
     * @param  int $logicId logicId (optional)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProgressionLive\Model\ProgressResult
     */
    public function taskIdentifierStatePost($identifier, $body = null, $logicId = null)
    {
        list($response) = $this->taskIdentifierStatePostWithHttpInfo($identifier, $body, $logicId);
        return $response;
    }

    /**
     * Operation taskIdentifierStatePostWithHttpInfo
     *
     * Change task's state.
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     * @param  \ProgressionLive\Model\Position $body To add a manual position (GPS point), the task must absolutely have an assigned human resource or else this command will be ignored (optional)
     * @param  int $logicId (optional)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProgressionLive\Model\ProgressResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskIdentifierStatePostWithHttpInfo($identifier, $body = null, $logicId = null)
    {
        $returnType = '\ProgressionLive\Model\ProgressResult';
        $request = $this->taskIdentifierStatePostRequest($identifier, $body, $logicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\ProgressResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\InlineResponse500',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskIdentifierStatePostAsync
     *
     * Change task's state.
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     * @param  \ProgressionLive\Model\Position $body To add a manual position (GPS point), the task must absolutely have an assigned human resource or else this command will be ignored (optional)
     * @param  int $logicId (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierStatePostAsync($identifier, $body = null, $logicId = null)
    {
        return $this->taskIdentifierStatePostAsyncWithHttpInfo($identifier, $body, $logicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskIdentifierStatePostAsyncWithHttpInfo
     *
     * Change task's state.
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     * @param  \ProgressionLive\Model\Position $body To add a manual position (GPS point), the task must absolutely have an assigned human resource or else this command will be ignored (optional)
     * @param  int $logicId (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierStatePostAsyncWithHttpInfo($identifier, $body = null, $logicId = null)
    {
        $returnType = '\ProgressionLive\Model\ProgressResult';
        $request = $this->taskIdentifierStatePostRequest($identifier, $body, $logicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskIdentifierStatePost'
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     * @param  \ProgressionLive\Model\Position $body To add a manual position (GPS point), the task must absolutely have an assigned human resource or else this command will be ignored (optional)
     * @param  int $logicId (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskIdentifierStatePostRequest($identifier, $body = null, $logicId = null)
    {
        // verify the required parameter 'identifier' is set
        if ($identifier === null || (is_array($identifier) && count($identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identifier when calling taskIdentifierStatePost'
            );
        }

        $resourcePath = '/task/{identifier}/state';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($logicId !== null) {
            $queryParams['logicId'] = ObjectSerializer::toQueryValue($logicId, 'int32');
        }

        // path params
        if ($identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'identifier' . '}',
                ObjectSerializer::toPathValue($identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskIdentifierTimeEntriesGet
     *
     * Get a task's time entries.
     *
     * @param  string $identifier Task&#x27;s identifier. One of id, uid, externalId or code. (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProgressionLive\Model\TimeEntry[]
     */
    public function taskIdentifierTimeEntriesGet($identifier)
    {
        list($response) = $this->taskIdentifierTimeEntriesGetWithHttpInfo($identifier);
        return $response;
    }

    /**
     * Operation taskIdentifierTimeEntriesGetWithHttpInfo
     *
     * Get a task's time entries.
     *
     * @param  string $identifier Task&#x27;s identifier. One of id, uid, externalId or code. (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProgressionLive\Model\TimeEntry[], HTTP status code, HTTP response headers (array of strings)
     */
    public function taskIdentifierTimeEntriesGetWithHttpInfo($identifier)
    {
        $returnType = '\ProgressionLive\Model\TimeEntry[]';
        $request = $this->taskIdentifierTimeEntriesGetRequest($identifier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\TimeEntry[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\InlineResponse500',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskIdentifierTimeEntriesGetAsync
     *
     * Get a task's time entries.
     *
     * @param  string $identifier Task&#x27;s identifier. One of id, uid, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierTimeEntriesGetAsync($identifier)
    {
        return $this->taskIdentifierTimeEntriesGetAsyncWithHttpInfo($identifier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskIdentifierTimeEntriesGetAsyncWithHttpInfo
     *
     * Get a task's time entries.
     *
     * @param  string $identifier Task&#x27;s identifier. One of id, uid, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierTimeEntriesGetAsyncWithHttpInfo($identifier)
    {
        $returnType = '\ProgressionLive\Model\TimeEntry[]';
        $request = $this->taskIdentifierTimeEntriesGetRequest($identifier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskIdentifierTimeEntriesGet'
     *
     * @param  string $identifier Task&#x27;s identifier. One of id, uid, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskIdentifierTimeEntriesGetRequest($identifier)
    {
        // verify the required parameter 'identifier' is set
        if ($identifier === null || (is_array($identifier) && count($identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identifier when calling taskIdentifierTimeEntriesGet'
            );
        }

        $resourcePath = '/task/{identifier}/timeEntries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'identifier' . '}',
                ObjectSerializer::toPathValue($identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskIdentifierUnlinkPost
     *
     * Unlink a task from its parent task, if a parent task is linked to it.
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProgressionLive\Model\ProgressResult
     */
    public function taskIdentifierUnlinkPost($identifier)
    {
        list($response) = $this->taskIdentifierUnlinkPostWithHttpInfo($identifier);
        return $response;
    }

    /**
     * Operation taskIdentifierUnlinkPostWithHttpInfo
     *
     * Unlink a task from its parent task, if a parent task is linked to it.
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProgressionLive\Model\ProgressResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskIdentifierUnlinkPostWithHttpInfo($identifier)
    {
        $returnType = '\ProgressionLive\Model\ProgressResult';
        $request = $this->taskIdentifierUnlinkPostRequest($identifier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\ProgressResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\InlineResponse500',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskIdentifierUnlinkPostAsync
     *
     * Unlink a task from its parent task, if a parent task is linked to it.
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierUnlinkPostAsync($identifier)
    {
        return $this->taskIdentifierUnlinkPostAsyncWithHttpInfo($identifier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskIdentifierUnlinkPostAsyncWithHttpInfo
     *
     * Unlink a task from its parent task, if a parent task is linked to it.
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierUnlinkPostAsyncWithHttpInfo($identifier)
    {
        $returnType = '\ProgressionLive\Model\ProgressResult';
        $request = $this->taskIdentifierUnlinkPostRequest($identifier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskIdentifierUnlinkPost'
     *
     * @param  string $identifier Task&#x27;s identifier. id, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskIdentifierUnlinkPostRequest($identifier)
    {
        // verify the required parameter 'identifier' is set
        if ($identifier === null || (is_array($identifier) && count($identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identifier when calling taskIdentifierUnlinkPost'
            );
        }

        $resourcePath = '/task/{identifier}/unlink';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'identifier' . '}',
                ObjectSerializer::toPathValue($identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskIdentifierUpdatePost
     *
     * Update a task. Only provided fields will be updated.
     *
     * @param  \ProgressionLive\Model\Task $body Task (required)
     * @param  string $identifier Task&#x27;s identifier. One of id, uid, externalId or code. (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function taskIdentifierUpdatePost($body, $identifier)
    {
        $this->taskIdentifierUpdatePostWithHttpInfo($body, $identifier);
    }

    /**
     * Operation taskIdentifierUpdatePostWithHttpInfo
     *
     * Update a task. Only provided fields will be updated.
     *
     * @param  \ProgressionLive\Model\Task $body Task (required)
     * @param  string $identifier Task&#x27;s identifier. One of id, uid, externalId or code. (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskIdentifierUpdatePostWithHttpInfo($body, $identifier)
    {
        $returnType = '';
        $request = $this->taskIdentifierUpdatePostRequest($body, $identifier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\InlineResponse500',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskIdentifierUpdatePostAsync
     *
     * Update a task. Only provided fields will be updated.
     *
     * @param  \ProgressionLive\Model\Task $body Task (required)
     * @param  string $identifier Task&#x27;s identifier. One of id, uid, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierUpdatePostAsync($body, $identifier)
    {
        return $this->taskIdentifierUpdatePostAsyncWithHttpInfo($body, $identifier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskIdentifierUpdatePostAsyncWithHttpInfo
     *
     * Update a task. Only provided fields will be updated.
     *
     * @param  \ProgressionLive\Model\Task $body Task (required)
     * @param  string $identifier Task&#x27;s identifier. One of id, uid, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskIdentifierUpdatePostAsyncWithHttpInfo($body, $identifier)
    {
        $returnType = '';
        $request = $this->taskIdentifierUpdatePostRequest($body, $identifier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskIdentifierUpdatePost'
     *
     * @param  \ProgressionLive\Model\Task $body Task (required)
     * @param  string $identifier Task&#x27;s identifier. One of id, uid, externalId or code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskIdentifierUpdatePostRequest($body, $identifier)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling taskIdentifierUpdatePost'
            );
        }
        // verify the required parameter 'identifier' is set
        if ($identifier === null || (is_array($identifier) && count($identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identifier when calling taskIdentifierUpdatePost'
            );
        }

        $resourcePath = '/task/{identifier}/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'identifier' . '}',
                ObjectSerializer::toPathValue($identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskListGet
     *
     * Search for tasks.
     *
     * @param  int $maxResults Maximum number of results to return. The default maximum number is 500 and cannot be exceeded. (optional)
     * @param  int $startResult Buffer data range to ignore before fetching the data. In combination with the maxResults, implements a pagination logic.  Example : 1000 results to fetch StartResult &#x3D; 0, MaxResult &#x3D; 500 (results &#x3D; 1 à 500) StartResult &#x3D; 500, MaxResult &#x3D; 500 (results &#x3D; 501 à 1000) (optional)
     * @param  string $type Filter by task type. This can be the label OR prefix code of the type. (optional)
     * @param  string $logicId Filter by logicId of the current state of the task.   Multiple states can be specified separated by commas, e.g.: 100,200.   It is also possible to specify the operators &#x27;&gt;&#x27; or &#x27;&lt;&#x27;, e.g.: &gt;100,&lt;600. (optional)
     * @param  string $rv Filter by task date (rendez-vous).   You can specify a date or a period with or without times.   e.g.: rv&#x3D;null, rv&#x3D;2018-01-25, rv&#x3D;2018-01-25,2018-01-28, rv&#x3D;2018-01-25T13:00:00-05,2018-01-25T17:00:00-05 (optional)
     * @param  string $updated Filter by task last updated timestamp.   You can specify a more recent date or a period.   e.g.: updated&#x3D;2018-01-25T13:00:00-05, updated&#x3D;2018-01-25T13:00:00-05,2018-01-25T17:00:00-05 (optional)
     * @param  string $properties Filter by custom fields. The syntax is: properties&#x3D;name:value[:operator].   The parameter can be specified multiple times to search multiple fields at once. The operator &#x27;equal&#x27; is used as default, but it is possible to change it by precising [:operator], which can take one of these values:  Not equal -&gt; &#x27;ne&#x27;;   Lower than -&gt; &#x27;lt&#x27;;  Lower or equal than -&gt; &#x27;le&#x27;;  Greater than -&gt; &#x27;gt&#x27;;  Greater or equal than -&gt; &#x27;ge&#x27;;  Contains sample (frame sample by %..%) -&gt; &#x27;like&#x27;;  Does not contain sample (frame sample by %..%) -&gt; &#x27;nlike&#x27;. (optional)
     * @param  string $metas Filter by metafields. The syntax is: metas&#x3D;name:value.   The parameter can be specified multiple times to search multiple metas at once. (optional)
     * @param  string $externalId Filter by externalId. This field is unique so you will never get more than one result. (optional)
     * @param  string $itemExternalId Filter by items externalId. This field is unique so you will never get more than one result. (optional)
     * @param  string $order Sort order of the results. It is possible to specify several sorts separated by commas as well as the sort direction.   e.g.: rv DESC,updated ASC (optional)
     * @param  string $client Filter by task client. The syntax is: client&#x3D;[uid, id, externalId, label:]value.  For example, to search for a client by its externalId we specify: client&#x3D;externalId:1234.  If the field is not specified we search by label by default. (optional)
     * @param  string $location Filter by task location. The syntax is: location&#x3D;[uid, id, externalId, label:]value.  For example, to search for a location by its externalId we specify: location&#x3D;externalId:1234.  If the field is not specified we search by label by default. (optional)
     * @param  string $humanResource Filter by task human resource. The syntax is: humanResource&#x3D;[uid, id, externalId, label:]value.  For example, to search for a human resource by its externalId we specify: humanResource&#x3D;externalId:1234.  If the field is not specified we search by label by default. (optional)
     * @param  string $parent Filter by parent task: get all children task of the task provided. One of id or code (optional)
     * @param  string $expand Fields to \&quot;expand\&quot;. Allows to fetch all related entity data instead of only ID and label.   e.g.: client (optional)
     * @param  string $onlyFieldsToInclude Fields to include exclusively in the JSON response body. Allows to get faster response when doing huge batch researches.  e.g.: properties,client,location,address (id,uid,label,code are included by default) (optional)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProgressionLive\Model\Task[]
     */
    public function taskListGet($maxResults = null, $startResult = null, $type = null, $logicId = null, $rv = null, $updated = null, $properties = null, $metas = null, $externalId = null, $itemExternalId = null, $order = null, $client = null, $location = null, $humanResource = null, $parent = null, $expand = null, $onlyFieldsToInclude = null)
    {
        list($response) = $this->taskListGetWithHttpInfo($maxResults, $startResult, $type, $logicId, $rv, $updated, $properties, $metas, $externalId, $itemExternalId, $order, $client, $location, $humanResource, $parent, $expand, $onlyFieldsToInclude);
        return $response;
    }

    /**
     * Operation taskListGetWithHttpInfo
     *
     * Search for tasks.
     *
     * @param  int $maxResults Maximum number of results to return. The default maximum number is 500 and cannot be exceeded. (optional)
     * @param  int $startResult Buffer data range to ignore before fetching the data. In combination with the maxResults, implements a pagination logic.  Example : 1000 results to fetch StartResult &#x3D; 0, MaxResult &#x3D; 500 (results &#x3D; 1 à 500) StartResult &#x3D; 500, MaxResult &#x3D; 500 (results &#x3D; 501 à 1000) (optional)
     * @param  string $type Filter by task type. This can be the label OR prefix code of the type. (optional)
     * @param  string $logicId Filter by logicId of the current state of the task.   Multiple states can be specified separated by commas, e.g.: 100,200.   It is also possible to specify the operators &#x27;&gt;&#x27; or &#x27;&lt;&#x27;, e.g.: &gt;100,&lt;600. (optional)
     * @param  string $rv Filter by task date (rendez-vous).   You can specify a date or a period with or without times.   e.g.: rv&#x3D;null, rv&#x3D;2018-01-25, rv&#x3D;2018-01-25,2018-01-28, rv&#x3D;2018-01-25T13:00:00-05,2018-01-25T17:00:00-05 (optional)
     * @param  string $updated Filter by task last updated timestamp.   You can specify a more recent date or a period.   e.g.: updated&#x3D;2018-01-25T13:00:00-05, updated&#x3D;2018-01-25T13:00:00-05,2018-01-25T17:00:00-05 (optional)
     * @param  string $properties Filter by custom fields. The syntax is: properties&#x3D;name:value[:operator].   The parameter can be specified multiple times to search multiple fields at once. The operator &#x27;equal&#x27; is used as default, but it is possible to change it by precising [:operator], which can take one of these values:  Not equal -&gt; &#x27;ne&#x27;;   Lower than -&gt; &#x27;lt&#x27;;  Lower or equal than -&gt; &#x27;le&#x27;;  Greater than -&gt; &#x27;gt&#x27;;  Greater or equal than -&gt; &#x27;ge&#x27;;  Contains sample (frame sample by %..%) -&gt; &#x27;like&#x27;;  Does not contain sample (frame sample by %..%) -&gt; &#x27;nlike&#x27;. (optional)
     * @param  string $metas Filter by metafields. The syntax is: metas&#x3D;name:value.   The parameter can be specified multiple times to search multiple metas at once. (optional)
     * @param  string $externalId Filter by externalId. This field is unique so you will never get more than one result. (optional)
     * @param  string $itemExternalId Filter by items externalId. This field is unique so you will never get more than one result. (optional)
     * @param  string $order Sort order of the results. It is possible to specify several sorts separated by commas as well as the sort direction.   e.g.: rv DESC,updated ASC (optional)
     * @param  string $client Filter by task client. The syntax is: client&#x3D;[uid, id, externalId, label:]value.  For example, to search for a client by its externalId we specify: client&#x3D;externalId:1234.  If the field is not specified we search by label by default. (optional)
     * @param  string $location Filter by task location. The syntax is: location&#x3D;[uid, id, externalId, label:]value.  For example, to search for a location by its externalId we specify: location&#x3D;externalId:1234.  If the field is not specified we search by label by default. (optional)
     * @param  string $humanResource Filter by task human resource. The syntax is: humanResource&#x3D;[uid, id, externalId, label:]value.  For example, to search for a human resource by its externalId we specify: humanResource&#x3D;externalId:1234.  If the field is not specified we search by label by default. (optional)
     * @param  string $parent Filter by parent task: get all children task of the task provided. One of id or code (optional)
     * @param  string $expand Fields to \&quot;expand\&quot;. Allows to fetch all related entity data instead of only ID and label.   e.g.: client (optional)
     * @param  string $onlyFieldsToInclude Fields to include exclusively in the JSON response body. Allows to get faster response when doing huge batch researches.  e.g.: properties,client,location,address (id,uid,label,code are included by default) (optional)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProgressionLive\Model\Task[], HTTP status code, HTTP response headers (array of strings)
     */
    public function taskListGetWithHttpInfo($maxResults = null, $startResult = null, $type = null, $logicId = null, $rv = null, $updated = null, $properties = null, $metas = null, $externalId = null, $itemExternalId = null, $order = null, $client = null, $location = null, $humanResource = null, $parent = null, $expand = null, $onlyFieldsToInclude = null)
    {
        $returnType = '\ProgressionLive\Model\Task[]';
        $request = $this->taskListGetRequest($maxResults, $startResult, $type, $logicId, $rv, $updated, $properties, $metas, $externalId, $itemExternalId, $order, $client, $location, $humanResource, $parent, $expand, $onlyFieldsToInclude);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\Task[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\InlineResponse500',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskListGetAsync
     *
     * Search for tasks.
     *
     * @param  int $maxResults Maximum number of results to return. The default maximum number is 500 and cannot be exceeded. (optional)
     * @param  int $startResult Buffer data range to ignore before fetching the data. In combination with the maxResults, implements a pagination logic.  Example : 1000 results to fetch StartResult &#x3D; 0, MaxResult &#x3D; 500 (results &#x3D; 1 à 500) StartResult &#x3D; 500, MaxResult &#x3D; 500 (results &#x3D; 501 à 1000) (optional)
     * @param  string $type Filter by task type. This can be the label OR prefix code of the type. (optional)
     * @param  string $logicId Filter by logicId of the current state of the task.   Multiple states can be specified separated by commas, e.g.: 100,200.   It is also possible to specify the operators &#x27;&gt;&#x27; or &#x27;&lt;&#x27;, e.g.: &gt;100,&lt;600. (optional)
     * @param  string $rv Filter by task date (rendez-vous).   You can specify a date or a period with or without times.   e.g.: rv&#x3D;null, rv&#x3D;2018-01-25, rv&#x3D;2018-01-25,2018-01-28, rv&#x3D;2018-01-25T13:00:00-05,2018-01-25T17:00:00-05 (optional)
     * @param  string $updated Filter by task last updated timestamp.   You can specify a more recent date or a period.   e.g.: updated&#x3D;2018-01-25T13:00:00-05, updated&#x3D;2018-01-25T13:00:00-05,2018-01-25T17:00:00-05 (optional)
     * @param  string $properties Filter by custom fields. The syntax is: properties&#x3D;name:value[:operator].   The parameter can be specified multiple times to search multiple fields at once. The operator &#x27;equal&#x27; is used as default, but it is possible to change it by precising [:operator], which can take one of these values:  Not equal -&gt; &#x27;ne&#x27;;   Lower than -&gt; &#x27;lt&#x27;;  Lower or equal than -&gt; &#x27;le&#x27;;  Greater than -&gt; &#x27;gt&#x27;;  Greater or equal than -&gt; &#x27;ge&#x27;;  Contains sample (frame sample by %..%) -&gt; &#x27;like&#x27;;  Does not contain sample (frame sample by %..%) -&gt; &#x27;nlike&#x27;. (optional)
     * @param  string $metas Filter by metafields. The syntax is: metas&#x3D;name:value.   The parameter can be specified multiple times to search multiple metas at once. (optional)
     * @param  string $externalId Filter by externalId. This field is unique so you will never get more than one result. (optional)
     * @param  string $itemExternalId Filter by items externalId. This field is unique so you will never get more than one result. (optional)
     * @param  string $order Sort order of the results. It is possible to specify several sorts separated by commas as well as the sort direction.   e.g.: rv DESC,updated ASC (optional)
     * @param  string $client Filter by task client. The syntax is: client&#x3D;[uid, id, externalId, label:]value.  For example, to search for a client by its externalId we specify: client&#x3D;externalId:1234.  If the field is not specified we search by label by default. (optional)
     * @param  string $location Filter by task location. The syntax is: location&#x3D;[uid, id, externalId, label:]value.  For example, to search for a location by its externalId we specify: location&#x3D;externalId:1234.  If the field is not specified we search by label by default. (optional)
     * @param  string $humanResource Filter by task human resource. The syntax is: humanResource&#x3D;[uid, id, externalId, label:]value.  For example, to search for a human resource by its externalId we specify: humanResource&#x3D;externalId:1234.  If the field is not specified we search by label by default. (optional)
     * @param  string $parent Filter by parent task: get all children task of the task provided. One of id or code (optional)
     * @param  string $expand Fields to \&quot;expand\&quot;. Allows to fetch all related entity data instead of only ID and label.   e.g.: client (optional)
     * @param  string $onlyFieldsToInclude Fields to include exclusively in the JSON response body. Allows to get faster response when doing huge batch researches.  e.g.: properties,client,location,address (id,uid,label,code are included by default) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskListGetAsync($maxResults = null, $startResult = null, $type = null, $logicId = null, $rv = null, $updated = null, $properties = null, $metas = null, $externalId = null, $itemExternalId = null, $order = null, $client = null, $location = null, $humanResource = null, $parent = null, $expand = null, $onlyFieldsToInclude = null)
    {
        return $this->taskListGetAsyncWithHttpInfo($maxResults, $startResult, $type, $logicId, $rv, $updated, $properties, $metas, $externalId, $itemExternalId, $order, $client, $location, $humanResource, $parent, $expand, $onlyFieldsToInclude)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskListGetAsyncWithHttpInfo
     *
     * Search for tasks.
     *
     * @param  int $maxResults Maximum number of results to return. The default maximum number is 500 and cannot be exceeded. (optional)
     * @param  int $startResult Buffer data range to ignore before fetching the data. In combination with the maxResults, implements a pagination logic.  Example : 1000 results to fetch StartResult &#x3D; 0, MaxResult &#x3D; 500 (results &#x3D; 1 à 500) StartResult &#x3D; 500, MaxResult &#x3D; 500 (results &#x3D; 501 à 1000) (optional)
     * @param  string $type Filter by task type. This can be the label OR prefix code of the type. (optional)
     * @param  string $logicId Filter by logicId of the current state of the task.   Multiple states can be specified separated by commas, e.g.: 100,200.   It is also possible to specify the operators &#x27;&gt;&#x27; or &#x27;&lt;&#x27;, e.g.: &gt;100,&lt;600. (optional)
     * @param  string $rv Filter by task date (rendez-vous).   You can specify a date or a period with or without times.   e.g.: rv&#x3D;null, rv&#x3D;2018-01-25, rv&#x3D;2018-01-25,2018-01-28, rv&#x3D;2018-01-25T13:00:00-05,2018-01-25T17:00:00-05 (optional)
     * @param  string $updated Filter by task last updated timestamp.   You can specify a more recent date or a period.   e.g.: updated&#x3D;2018-01-25T13:00:00-05, updated&#x3D;2018-01-25T13:00:00-05,2018-01-25T17:00:00-05 (optional)
     * @param  string $properties Filter by custom fields. The syntax is: properties&#x3D;name:value[:operator].   The parameter can be specified multiple times to search multiple fields at once. The operator &#x27;equal&#x27; is used as default, but it is possible to change it by precising [:operator], which can take one of these values:  Not equal -&gt; &#x27;ne&#x27;;   Lower than -&gt; &#x27;lt&#x27;;  Lower or equal than -&gt; &#x27;le&#x27;;  Greater than -&gt; &#x27;gt&#x27;;  Greater or equal than -&gt; &#x27;ge&#x27;;  Contains sample (frame sample by %..%) -&gt; &#x27;like&#x27;;  Does not contain sample (frame sample by %..%) -&gt; &#x27;nlike&#x27;. (optional)
     * @param  string $metas Filter by metafields. The syntax is: metas&#x3D;name:value.   The parameter can be specified multiple times to search multiple metas at once. (optional)
     * @param  string $externalId Filter by externalId. This field is unique so you will never get more than one result. (optional)
     * @param  string $itemExternalId Filter by items externalId. This field is unique so you will never get more than one result. (optional)
     * @param  string $order Sort order of the results. It is possible to specify several sorts separated by commas as well as the sort direction.   e.g.: rv DESC,updated ASC (optional)
     * @param  string $client Filter by task client. The syntax is: client&#x3D;[uid, id, externalId, label:]value.  For example, to search for a client by its externalId we specify: client&#x3D;externalId:1234.  If the field is not specified we search by label by default. (optional)
     * @param  string $location Filter by task location. The syntax is: location&#x3D;[uid, id, externalId, label:]value.  For example, to search for a location by its externalId we specify: location&#x3D;externalId:1234.  If the field is not specified we search by label by default. (optional)
     * @param  string $humanResource Filter by task human resource. The syntax is: humanResource&#x3D;[uid, id, externalId, label:]value.  For example, to search for a human resource by its externalId we specify: humanResource&#x3D;externalId:1234.  If the field is not specified we search by label by default. (optional)
     * @param  string $parent Filter by parent task: get all children task of the task provided. One of id or code (optional)
     * @param  string $expand Fields to \&quot;expand\&quot;. Allows to fetch all related entity data instead of only ID and label.   e.g.: client (optional)
     * @param  string $onlyFieldsToInclude Fields to include exclusively in the JSON response body. Allows to get faster response when doing huge batch researches.  e.g.: properties,client,location,address (id,uid,label,code are included by default) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskListGetAsyncWithHttpInfo($maxResults = null, $startResult = null, $type = null, $logicId = null, $rv = null, $updated = null, $properties = null, $metas = null, $externalId = null, $itemExternalId = null, $order = null, $client = null, $location = null, $humanResource = null, $parent = null, $expand = null, $onlyFieldsToInclude = null)
    {
        $returnType = '\ProgressionLive\Model\Task[]';
        $request = $this->taskListGetRequest($maxResults, $startResult, $type, $logicId, $rv, $updated, $properties, $metas, $externalId, $itemExternalId, $order, $client, $location, $humanResource, $parent, $expand, $onlyFieldsToInclude);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskListGet'
     *
     * @param  int $maxResults Maximum number of results to return. The default maximum number is 500 and cannot be exceeded. (optional)
     * @param  int $startResult Buffer data range to ignore before fetching the data. In combination with the maxResults, implements a pagination logic.  Example : 1000 results to fetch StartResult &#x3D; 0, MaxResult &#x3D; 500 (results &#x3D; 1 à 500) StartResult &#x3D; 500, MaxResult &#x3D; 500 (results &#x3D; 501 à 1000) (optional)
     * @param  string $type Filter by task type. This can be the label OR prefix code of the type. (optional)
     * @param  string $logicId Filter by logicId of the current state of the task.   Multiple states can be specified separated by commas, e.g.: 100,200.   It is also possible to specify the operators &#x27;&gt;&#x27; or &#x27;&lt;&#x27;, e.g.: &gt;100,&lt;600. (optional)
     * @param  string $rv Filter by task date (rendez-vous).   You can specify a date or a period with or without times.   e.g.: rv&#x3D;null, rv&#x3D;2018-01-25, rv&#x3D;2018-01-25,2018-01-28, rv&#x3D;2018-01-25T13:00:00-05,2018-01-25T17:00:00-05 (optional)
     * @param  string $updated Filter by task last updated timestamp.   You can specify a more recent date or a period.   e.g.: updated&#x3D;2018-01-25T13:00:00-05, updated&#x3D;2018-01-25T13:00:00-05,2018-01-25T17:00:00-05 (optional)
     * @param  string $properties Filter by custom fields. The syntax is: properties&#x3D;name:value[:operator].   The parameter can be specified multiple times to search multiple fields at once. The operator &#x27;equal&#x27; is used as default, but it is possible to change it by precising [:operator], which can take one of these values:  Not equal -&gt; &#x27;ne&#x27;;   Lower than -&gt; &#x27;lt&#x27;;  Lower or equal than -&gt; &#x27;le&#x27;;  Greater than -&gt; &#x27;gt&#x27;;  Greater or equal than -&gt; &#x27;ge&#x27;;  Contains sample (frame sample by %..%) -&gt; &#x27;like&#x27;;  Does not contain sample (frame sample by %..%) -&gt; &#x27;nlike&#x27;. (optional)
     * @param  string $metas Filter by metafields. The syntax is: metas&#x3D;name:value.   The parameter can be specified multiple times to search multiple metas at once. (optional)
     * @param  string $externalId Filter by externalId. This field is unique so you will never get more than one result. (optional)
     * @param  string $itemExternalId Filter by items externalId. This field is unique so you will never get more than one result. (optional)
     * @param  string $order Sort order of the results. It is possible to specify several sorts separated by commas as well as the sort direction.   e.g.: rv DESC,updated ASC (optional)
     * @param  string $client Filter by task client. The syntax is: client&#x3D;[uid, id, externalId, label:]value.  For example, to search for a client by its externalId we specify: client&#x3D;externalId:1234.  If the field is not specified we search by label by default. (optional)
     * @param  string $location Filter by task location. The syntax is: location&#x3D;[uid, id, externalId, label:]value.  For example, to search for a location by its externalId we specify: location&#x3D;externalId:1234.  If the field is not specified we search by label by default. (optional)
     * @param  string $humanResource Filter by task human resource. The syntax is: humanResource&#x3D;[uid, id, externalId, label:]value.  For example, to search for a human resource by its externalId we specify: humanResource&#x3D;externalId:1234.  If the field is not specified we search by label by default. (optional)
     * @param  string $parent Filter by parent task: get all children task of the task provided. One of id or code (optional)
     * @param  string $expand Fields to \&quot;expand\&quot;. Allows to fetch all related entity data instead of only ID and label.   e.g.: client (optional)
     * @param  string $onlyFieldsToInclude Fields to include exclusively in the JSON response body. Allows to get faster response when doing huge batch researches.  e.g.: properties,client,location,address (id,uid,label,code are included by default) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskListGetRequest($maxResults = null, $startResult = null, $type = null, $logicId = null, $rv = null, $updated = null, $properties = null, $metas = null, $externalId = null, $itemExternalId = null, $order = null, $client = null, $location = null, $humanResource = null, $parent = null, $expand = null, $onlyFieldsToInclude = null)
    {

        $resourcePath = '/task/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($maxResults !== null) {
            $queryParams['maxResults'] = ObjectSerializer::toQueryValue($maxResults, 'int32');
        }
        // query params
        if ($startResult !== null) {
            $queryParams['startResult'] = ObjectSerializer::toQueryValue($startResult, 'int32');
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type, null);
        }
        // query params
        if ($logicId !== null) {
            $queryParams['logicId'] = ObjectSerializer::toQueryValue($logicId, null);
        }
        // query params
        if ($rv !== null) {
            $queryParams['rv'] = ObjectSerializer::toQueryValue($rv, null);
        }
        // query params
        if ($updated !== null) {
            $queryParams['updated'] = ObjectSerializer::toQueryValue($updated, null);
        }
        // query params
        if ($properties !== null) {
            $queryParams['properties'] = ObjectSerializer::toQueryValue($properties, null);
        }
        // query params
        if ($metas !== null) {
            $queryParams['metas'] = ObjectSerializer::toQueryValue($metas, null);
        }
        // query params
        if ($externalId !== null) {
            $queryParams['externalId'] = ObjectSerializer::toQueryValue($externalId, null);
        }
        // query params
        if ($itemExternalId !== null) {
            $queryParams['itemExternalId'] = ObjectSerializer::toQueryValue($itemExternalId, null);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order, null);
        }
        // query params
        if ($client !== null) {
            $queryParams['client'] = ObjectSerializer::toQueryValue($client, null);
        }
        // query params
        if ($location !== null) {
            $queryParams['location'] = ObjectSerializer::toQueryValue($location, null);
        }
        // query params
        if ($humanResource !== null) {
            $queryParams['humanResource'] = ObjectSerializer::toQueryValue($humanResource, null);
        }
        // query params
        if ($parent !== null) {
            $queryParams['parent'] = ObjectSerializer::toQueryValue($parent, null);
        }
        // query params
        if ($expand !== null) {
            $queryParams['expand'] = ObjectSerializer::toQueryValue($expand, null);
        }
        // query params
        if ($onlyFieldsToInclude !== null) {
            $queryParams['onlyFieldsToInclude'] = ObjectSerializer::toQueryValue($onlyFieldsToInclude, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskStateListGet
     *
     * Get multiple tasks state history.
     *
     * @param  int $maxResults Maximum number of results to return. The default maximum number is 500 and cannot be exceeded. (optional)
     * @param  int $startResult Buffer data range to ignore before fetching the data. In combination with the maxResults, implements a pagination logic.  Example : 1000 results to fetch StartResult &#x3D; 0, MaxResult &#x3D; 500 (results &#x3D; 1 à 500) StartResult &#x3D; 500, MaxResult &#x3D; 500 (results &#x3D; 501 à 1000) (optional)
     * @param  string $logicId Filter by logicId of the state.   Multiple states can be specified separated by commas, e.g.: 100,200.   It is also possible to specify the operators &#x27;&gt;&#x27; or &#x27;&lt;&#x27;, e.g.: &gt;100,&lt;600. (optional)
     * @param  string $datetime Filter by state change date and time.   You can specify a date or a period with or without times.   e.g.: rv&#x3D;2018-01-25, rv&#x3D;2018-01-25,2018-01-28, rv&#x3D;2018-01-25T13:00:00-05,2018-01-25T17:00:00-05 (optional)
     * @param  string $rv Filter states by task date (rendez-vous).   You can specify a date or a period with or without times.   e.g.: rv&#x3D;null, rv&#x3D;2018-01-25, rv&#x3D;2018-01-25,2018-01-28, rv&#x3D;2018-01-25T13:00:00-05,2018-01-25T17:00:00-05 (optional)
     * @param  string $expand expand (optional)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProgressionLive\Model\TaskState[]
     */
    public function taskStateListGet($maxResults = null, $startResult = null, $logicId = null, $datetime = null, $rv = null, $expand = null)
    {
        list($response) = $this->taskStateListGetWithHttpInfo($maxResults, $startResult, $logicId, $datetime, $rv, $expand);
        return $response;
    }

    /**
     * Operation taskStateListGetWithHttpInfo
     *
     * Get multiple tasks state history.
     *
     * @param  int $maxResults Maximum number of results to return. The default maximum number is 500 and cannot be exceeded. (optional)
     * @param  int $startResult Buffer data range to ignore before fetching the data. In combination with the maxResults, implements a pagination logic.  Example : 1000 results to fetch StartResult &#x3D; 0, MaxResult &#x3D; 500 (results &#x3D; 1 à 500) StartResult &#x3D; 500, MaxResult &#x3D; 500 (results &#x3D; 501 à 1000) (optional)
     * @param  string $logicId Filter by logicId of the state.   Multiple states can be specified separated by commas, e.g.: 100,200.   It is also possible to specify the operators &#x27;&gt;&#x27; or &#x27;&lt;&#x27;, e.g.: &gt;100,&lt;600. (optional)
     * @param  string $datetime Filter by state change date and time.   You can specify a date or a period with or without times.   e.g.: rv&#x3D;2018-01-25, rv&#x3D;2018-01-25,2018-01-28, rv&#x3D;2018-01-25T13:00:00-05,2018-01-25T17:00:00-05 (optional)
     * @param  string $rv Filter states by task date (rendez-vous).   You can specify a date or a period with or without times.   e.g.: rv&#x3D;null, rv&#x3D;2018-01-25, rv&#x3D;2018-01-25,2018-01-28, rv&#x3D;2018-01-25T13:00:00-05,2018-01-25T17:00:00-05 (optional)
     * @param  string $expand (optional)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProgressionLive\Model\TaskState[], HTTP status code, HTTP response headers (array of strings)
     */
    public function taskStateListGetWithHttpInfo($maxResults = null, $startResult = null, $logicId = null, $datetime = null, $rv = null, $expand = null)
    {
        $returnType = '\ProgressionLive\Model\TaskState[]';
        $request = $this->taskStateListGetRequest($maxResults, $startResult, $logicId, $datetime, $rv, $expand);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\TaskState[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\InlineResponse500',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskStateListGetAsync
     *
     * Get multiple tasks state history.
     *
     * @param  int $maxResults Maximum number of results to return. The default maximum number is 500 and cannot be exceeded. (optional)
     * @param  int $startResult Buffer data range to ignore before fetching the data. In combination with the maxResults, implements a pagination logic.  Example : 1000 results to fetch StartResult &#x3D; 0, MaxResult &#x3D; 500 (results &#x3D; 1 à 500) StartResult &#x3D; 500, MaxResult &#x3D; 500 (results &#x3D; 501 à 1000) (optional)
     * @param  string $logicId Filter by logicId of the state.   Multiple states can be specified separated by commas, e.g.: 100,200.   It is also possible to specify the operators &#x27;&gt;&#x27; or &#x27;&lt;&#x27;, e.g.: &gt;100,&lt;600. (optional)
     * @param  string $datetime Filter by state change date and time.   You can specify a date or a period with or without times.   e.g.: rv&#x3D;2018-01-25, rv&#x3D;2018-01-25,2018-01-28, rv&#x3D;2018-01-25T13:00:00-05,2018-01-25T17:00:00-05 (optional)
     * @param  string $rv Filter states by task date (rendez-vous).   You can specify a date or a period with or without times.   e.g.: rv&#x3D;null, rv&#x3D;2018-01-25, rv&#x3D;2018-01-25,2018-01-28, rv&#x3D;2018-01-25T13:00:00-05,2018-01-25T17:00:00-05 (optional)
     * @param  string $expand (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskStateListGetAsync($maxResults = null, $startResult = null, $logicId = null, $datetime = null, $rv = null, $expand = null)
    {
        return $this->taskStateListGetAsyncWithHttpInfo($maxResults, $startResult, $logicId, $datetime, $rv, $expand)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskStateListGetAsyncWithHttpInfo
     *
     * Get multiple tasks state history.
     *
     * @param  int $maxResults Maximum number of results to return. The default maximum number is 500 and cannot be exceeded. (optional)
     * @param  int $startResult Buffer data range to ignore before fetching the data. In combination with the maxResults, implements a pagination logic.  Example : 1000 results to fetch StartResult &#x3D; 0, MaxResult &#x3D; 500 (results &#x3D; 1 à 500) StartResult &#x3D; 500, MaxResult &#x3D; 500 (results &#x3D; 501 à 1000) (optional)
     * @param  string $logicId Filter by logicId of the state.   Multiple states can be specified separated by commas, e.g.: 100,200.   It is also possible to specify the operators &#x27;&gt;&#x27; or &#x27;&lt;&#x27;, e.g.: &gt;100,&lt;600. (optional)
     * @param  string $datetime Filter by state change date and time.   You can specify a date or a period with or without times.   e.g.: rv&#x3D;2018-01-25, rv&#x3D;2018-01-25,2018-01-28, rv&#x3D;2018-01-25T13:00:00-05,2018-01-25T17:00:00-05 (optional)
     * @param  string $rv Filter states by task date (rendez-vous).   You can specify a date or a period with or without times.   e.g.: rv&#x3D;null, rv&#x3D;2018-01-25, rv&#x3D;2018-01-25,2018-01-28, rv&#x3D;2018-01-25T13:00:00-05,2018-01-25T17:00:00-05 (optional)
     * @param  string $expand (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskStateListGetAsyncWithHttpInfo($maxResults = null, $startResult = null, $logicId = null, $datetime = null, $rv = null, $expand = null)
    {
        $returnType = '\ProgressionLive\Model\TaskState[]';
        $request = $this->taskStateListGetRequest($maxResults, $startResult, $logicId, $datetime, $rv, $expand);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskStateListGet'
     *
     * @param  int $maxResults Maximum number of results to return. The default maximum number is 500 and cannot be exceeded. (optional)
     * @param  int $startResult Buffer data range to ignore before fetching the data. In combination with the maxResults, implements a pagination logic.  Example : 1000 results to fetch StartResult &#x3D; 0, MaxResult &#x3D; 500 (results &#x3D; 1 à 500) StartResult &#x3D; 500, MaxResult &#x3D; 500 (results &#x3D; 501 à 1000) (optional)
     * @param  string $logicId Filter by logicId of the state.   Multiple states can be specified separated by commas, e.g.: 100,200.   It is also possible to specify the operators &#x27;&gt;&#x27; or &#x27;&lt;&#x27;, e.g.: &gt;100,&lt;600. (optional)
     * @param  string $datetime Filter by state change date and time.   You can specify a date or a period with or without times.   e.g.: rv&#x3D;2018-01-25, rv&#x3D;2018-01-25,2018-01-28, rv&#x3D;2018-01-25T13:00:00-05,2018-01-25T17:00:00-05 (optional)
     * @param  string $rv Filter states by task date (rendez-vous).   You can specify a date or a period with or without times.   e.g.: rv&#x3D;null, rv&#x3D;2018-01-25, rv&#x3D;2018-01-25,2018-01-28, rv&#x3D;2018-01-25T13:00:00-05,2018-01-25T17:00:00-05 (optional)
     * @param  string $expand (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskStateListGetRequest($maxResults = null, $startResult = null, $logicId = null, $datetime = null, $rv = null, $expand = null)
    {

        $resourcePath = '/task/state/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($maxResults !== null) {
            $queryParams['maxResults'] = ObjectSerializer::toQueryValue($maxResults, 'int32');
        }
        // query params
        if ($startResult !== null) {
            $queryParams['startResult'] = ObjectSerializer::toQueryValue($startResult, 'int32');
        }
        // query params
        if ($logicId !== null) {
            $queryParams['logicId'] = ObjectSerializer::toQueryValue($logicId, null);
        }
        // query params
        if ($datetime !== null) {
            $queryParams['datetime'] = ObjectSerializer::toQueryValue($datetime, null);
        }
        // query params
        if ($rv !== null) {
            $queryParams['rv'] = ObjectSerializer::toQueryValue($rv, null);
        }
        // query params
        if ($expand !== null) {
            $queryParams['expand'] = ObjectSerializer::toQueryValue($expand, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskStatePost
     *
     * Change multiple tasks state.
     *
     * @param  \ProgressionLive\Model\MultipleProgressRequest $body To add a manual position (GPS point), the task must absolutely have an assigned human resource or else this command will be ignored (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ProgressionLive\Model\ProgressResult[]
     */
    public function taskStatePost($body)
    {
        list($response) = $this->taskStatePostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation taskStatePostWithHttpInfo
     *
     * Change multiple tasks state.
     *
     * @param  \ProgressionLive\Model\MultipleProgressRequest $body To add a manual position (GPS point), the task must absolutely have an assigned human resource or else this command will be ignored (required)
     *
     * @throws \ProgressionLive\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ProgressionLive\Model\ProgressResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function taskStatePostWithHttpInfo($body)
    {
        $returnType = '\ProgressionLive\Model\ProgressResult[]';
        $request = $this->taskStatePostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\ProgressResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ProgressionLive\Model\InlineResponse500',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskStatePostAsync
     *
     * Change multiple tasks state.
     *
     * @param  \ProgressionLive\Model\MultipleProgressRequest $body To add a manual position (GPS point), the task must absolutely have an assigned human resource or else this command will be ignored (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskStatePostAsync($body)
    {
        return $this->taskStatePostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskStatePostAsyncWithHttpInfo
     *
     * Change multiple tasks state.
     *
     * @param  \ProgressionLive\Model\MultipleProgressRequest $body To add a manual position (GPS point), the task must absolutely have an assigned human resource or else this command will be ignored (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskStatePostAsyncWithHttpInfo($body)
    {
        $returnType = '\ProgressionLive\Model\ProgressResult[]';
        $request = $this->taskStatePostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskStatePost'
     *
     * @param  \ProgressionLive\Model\MultipleProgressRequest $body To add a manual position (GPS point), the task must absolutely have an assigned human resource or else this command will be ignored (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskStatePostRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling taskStatePost'
            );
        }

        $resourcePath = '/task/state';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
